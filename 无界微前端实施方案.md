# 🚀 无界微前端详细实施方案

## 项目概述

本文档提供了将羽毛球场预定系统改造为微前端架构的详细实施方案，使用无界(wujie)框架实现C端(Vue3)和B端(React19)的集成。

### 当前架构
- **C端系统**：Vue 3 + Element Plus + Pinia + Vite (主端口)
- **B端系统**：React 19 + Ant Design + Zustand + Vite (端口5000)

### 目标架构
```
主应用(C端) - Vue 3 + 无界
├── 首页、商城、论坛、用户中心等 (原有功能)
├── /admin/* 路由 → 加载B端React应用
└── 共享状态管理(用户登录状态等)

子应用(B端) - React 19 
├── 独立运行在端口5000
├── 管理后台所有功能
└── 接收主应用传递的用户信息
```

## 第一阶段：主应用(C端Vue3)改造

### 1.1 安装依赖

```bash
# 在C端项目根目录执行
pnpm add wujie-vue3
```

### 1.2 全局配置无界

创建 `src/plugins/wujie.js`：

```javascript
import { bus, setupApp, preloadApp, startApp } from 'wujie'
import { ElMessage } from 'element-plus'

// 无界配置
const wujieConfig = {
  // 子应用配置
  apps: {
    'react-admin': {
      // 开发环境地址
      devUrl: 'http://localhost:5000',
      // 生产环境地址  
      prodUrl: '/admin-static',
      // 预加载
      preload: true,
      // 保活模式
      alive: true,
      // 路由同步
      sync: true,
      // 自定义fetch
      fetch: (url, options) => {
        return window.fetch(url, {
          ...options,
          headers: {
            ...options?.headers,
            'Access-Control-Allow-Origin': '*',
          }
        })
      },
      // 子应用加载前
      beforeLoad: (appWindow) => {
        console.log('子应用加载前:', appWindow)
      },
      // 子应用加载后
      beforeMount: (appWindow) => {
        console.log('子应用挂载前:', appWindow)
      },
      // 子应用挂载后
      afterMount: (appWindow) => {
        console.log('子应用挂载后:', appWindow)
      },
      // 子应用卸载前
      beforeUnmount: (appWindow) => {
        console.log('子应用卸载前:', appWindow)
      },
      // 子应用卸载后
      afterUnmount: (appWindow) => {
        console.log('子应用卸载后:', appWindow)
      }
    }
  }
}

// 初始化无界
export function initWujie() {
  // 设置子应用
  setupApp({
    name: 'react-admin',
    url: process.env.NODE_ENV === 'development' 
      ? wujieConfig.apps['react-admin'].devUrl 
      : wujieConfig.apps['react-admin'].prodUrl,
    alive: wujieConfig.apps['react-admin'].alive,
    ...wujieConfig.apps['react-admin']
  })

  // 预加载子应用
  if (wujieConfig.apps['react-admin'].preload) {
    preloadApp({
      name: 'react-admin',
      url: process.env.NODE_ENV === 'development' 
        ? wujieConfig.apps['react-admin'].devUrl 
        : wujieConfig.apps['react-admin'].prodUrl
    })
  }
}

// 启动子应用
export function startReactAdmin(container, props = {}) {
  return startApp({
    name: 'react-admin',
    url: process.env.NODE_ENV === 'development' 
      ? wujieConfig.apps['react-admin'].devUrl 
      : wujieConfig.apps['react-admin'].prodUrl,
    el: container,
    props,
    alive: true,
    sync: true
  })
}

export { bus }
```

### 1.3 在main.js中初始化

修改 `src/main.js`：

```javascript
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
import '@/assets/common.css'

// 导入无界配置
import { initWujie } from '@/plugins/wujie'

const app = createApp(App)
const pinia = createPinia()

pinia.use(piniaPluginPersistedstate)

app.use(pinia)
app.use(router)
app.use(ElementPlus)

// 初始化无界
initWujie()

app.mount('#app')
```

### 1.4 创建管理后台容器组件

创建 `src/views/admin/AdminContainer.vue`：

```vue
<template>
  <div class="admin-container">
    <!-- 加载状态 -->
    <div v-if="loading" class="loading-container">
      <el-loading-spinner />
      <p>正在加载管理后台...</p>
    </div>
    
    <!-- 无界容器 -->
    <WujieVue 
      v-show="!loading"
      name="react-admin"
      :url="adminUrl"
      :props="adminProps"
      :sync="true"
      :alive="true"
      width="100%"
      height="100vh"
      @mounted="handleMounted"
      @unmounted="handleUnmounted"
      @error="handleError"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue'
import WujieVue from 'wujie-vue3'
import { useUserStore } from '@/stores'
import { ElMessage } from 'element-plus'
import { bus } from '@/plugins/wujie'

const userStore = useUserStore()
const loading = ref(true)

// 计算管理后台URL
const adminUrl = computed(() => {
  return import.meta.env.DEV 
    ? 'http://localhost:5000' 
    : '/admin-static'
})

// 传递给子应用的数据
const adminProps = computed(() => ({
  userInfo: userStore.userinfo,
  token: userStore.token,
  theme: 'light', // 可以传递主题配置
  language: 'zh-CN' // 语言配置
}))

// 子应用挂载完成
const handleMounted = () => {
  loading.value = false
  console.log('管理后台加载完成')
  
  // 通知子应用用户信息
  bus.$emit('user-info-updated', adminProps.value)
}

// 子应用卸载
const handleUnmounted = () => {
  console.log('管理后台已卸载')
}

// 子应用加载错误
const handleError = (error) => {
  loading.value = false
  console.error('管理后台加载失败:', error)
  ElMessage.error('管理后台加载失败，请刷新重试')
}

// 监听用户信息变化
const handleUserInfoChange = () => {
  if (!loading.value) {
    bus.$emit('user-info-updated', adminProps.value)
  }
}

onMounted(() => {
  // 监听用户信息变化
  userStore.$subscribe(handleUserInfoChange)
  
  // 监听子应用消息
  bus.$on('admin-logout', () => {
    userStore.logout()
    ElMessage.success('已退出登录')
  })
  
  bus.$on('admin-navigate', (path) => {
    // 处理子应用导航请求
    console.log('子应用请求导航:', path)
  })
})

onUnmounted(() => {
  // 清理事件监听
  bus.$off('admin-logout')
  bus.$off('admin-navigate')
})
</script>

<style scoped>
.admin-container {
  width: 100%;
  height: 100vh;
  position: relative;
}

.loading-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
  background-color: #f5f5f5;
}

.loading-container p {
  margin-top: 16px;
  color: #666;
  font-size: 14px;
}
</style>
```

### 1.5 更新路由配置

修改 `src/router/index.js`，移除原有的admin路由，添加新的容器路由：

```javascript
import { createRouter, createWebHistory } from 'vue-router'
import { useUserStore } from '@/stores'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      component: () => import('@/views/layout/LayOut.vue'),
      redirect: '/home',
      meta: { title: '武汉理工大学南湖校区羽毛球场预定前台' },
      children: [
        // ... 保留原有的C端路由
        {
          path: '/home',
          component: () => import('@/views/home/HomeView.vue'),
          meta: { title: '武汉理工大学南湖校区羽毛球场预定前台' },
        },
        // ... 其他原有路由保持不变
      ],
    },
    // 新的管理后台路由 - 使用无界容器
    {
      path: '/admin/:pathMatch(.*)*',
      component: () => import('@/views/admin/AdminContainer.vue'),
      meta: { 
        requiresAdmin: true, 
        title: '管理后台',
        keepAlive: false // 不缓存，确保每次都是最新状态
      },
    },
    {
      path: '/login',
      component: () => import('@/views/login/Login.vue'),
      meta: { title: '登录/注册' },
      children: [
        {
          path: 'forget-password',
          component: () => import('@/views/login/ForgetPassword.vue'),
          meta: { title: '找回密码' },
        },
      ],
    },
  ],
})

// 路由守卫保持不变
router.beforeEach((to, from, next) => {
  // 设置页面标题
  if (to.meta.title) {
    document.title = to.meta.title
  }

  const userStore = useUserStore()

  if (to.meta.requiresAuth) {
    if (userStore.token && !userStore.isTokenExpired()) {
      next()
    } else {
      if (userStore.token && userStore.isTokenExpired()) {
        userStore.logout()
        ElMessage.warning('登录已过期，请重新登录')
      }
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    }
  } else if (to.meta.requiresAdmin) {
    if (userStore.token && !userStore.isTokenExpired()) {
      if (userStore.userinfo?.role === 'ROLE_ADMIN') {
        next()
      } else {
        ElMessage.error('您没有访问管理后台的权限')
        next('/')
      }
    } else {
      if (userStore.token && userStore.isTokenExpired()) {
        userStore.logout()
        ElMessage.warning('登录已过期，请重新登录')
      }
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    }
  } else {
    if (userStore.token && userStore.isTokenExpired() && to.meta.requiresAuth) {
      userStore.logout()
    }
    next()
  }
})

export default router
```

## 第二阶段：子应用(B端React19)改造

### 2.1 修改入口文件

修改 `admin-frontend/src/main.tsx`：

```typescript
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './App.tsx'
import './index.css'

// 声明全局类型
declare global {
  interface Window {
    __POWERED_BY_WUJIE__?: boolean
    __WUJIE_MOUNT?: () => void
    __WUJIE_UNMOUNT?: () => void
    __WUJIE?: {
      props?: any
      bus?: any
    }
  }
}

let root: any = null

// 渲染函数
function render(props: any = {}) {
  const container = document.querySelector('#root')
  if (container) {
    root = createRoot(container)
    root.render(
      <StrictMode>
        <App {...props} />
      </StrictMode>
    )
  }
}

// 卸载函数
function unmount() {
  if (root) {
    root.unmount()
    root = null
  }
}

// 判断是否在无界环境中
if (window.__POWERED_BY_WUJIE__) {
  // 在无界环境中
  window.__WUJIE_MOUNT = () => {
    const props = window.__WUJIE?.props || {}
    render(props)
  }
  
  window.__WUJIE_UNMOUNT = () => {
    unmount()
  }
} else {
  // 独立运行
  render()
}

// 监听无界Props更新
if (window.__WUJIE?.bus) {
  window.__WUJIE.bus.$on('user-info-updated', (props: any) => {
    // 可以在这里处理主应用传递的数据更新
    console.log('收到主应用数据更新:', props)
  })
}
```

### 2.2 创建无界通信Hook

创建 `admin-frontend/src/hooks/useWujie.ts`：

```typescript
import { useEffect, useState } from 'react'

interface WujieProps {
  userInfo?: any
  token?: string
  theme?: string
  language?: string
}

export function useWujie() {
  const [isWujie] = useState(!!window.__POWERED_BY_WUJIE__)
  const [wujieProps, setWujieProps] = useState<WujieProps>({})

  useEffect(() => {
    if (!isWujie) return

    // 获取初始props
    const initialProps = window.__WUJIE?.props || {}
    setWujieProps(initialProps)

    // 监听props更新
    const handlePropsUpdate = (props: WujieProps) => {
      setWujieProps(props)
    }

    if (window.__WUJIE?.bus) {
      window.__WUJIE.bus.$on('user-info-updated', handlePropsUpdate)
      
      return () => {
        window.__WUJIE.bus.$off('user-info-updated', handlePropsUpdate)
      }
    }
  }, [isWujie])

  // 向主应用发送消息
  const emitToParent = (event: string, data?: any) => {
    if (isWujie && window.__WUJIE?.bus) {
      window.__WUJIE.bus.$emit(event, data)
    }
  }

  // 导航到主应用路由
  const navigateToParent = (path: string) => {
    emitToParent('admin-navigate', path)
  }

  // 退出登录
  const logout = () => {
    emitToParent('admin-logout')
  }

  return {
    isWujie,
    wujieProps,
    emitToParent,
    navigateToParent,
    logout
  }
}
```

### 2.3 更新App组件

修改 `admin-frontend/src/App.tsx`：

```typescript
import React, { Suspense, useEffect } from 'react'
import { BrowserRouter } from 'react-router-dom'
import { ConfigProvider } from 'antd'
import zhCN from 'antd/locale/zh_CN'
import router from './router'
import { RouterProvider } from 'react-router-dom'
import { useWujie } from './hooks/useWujie'

interface AppProps {
  userInfo?: any
  token?: string
  theme?: string
  language?: string
}

function App(props: AppProps) {
  const { isWujie, wujieProps } = useWujie()
  
  // 合并props
  const finalProps = isWujie ? wujieProps : props

  useEffect(() => {
    // 处理从主应用传递的用户信息
    if (finalProps.userInfo) {
      console.log('收到用户信息:', finalProps.userInfo)
      // 可以更新全局状态
    }
    
    if (finalProps.token) {
      console.log('收到token:', finalProps.token)
      // 可以设置axios默认header
    }
  }, [finalProps])

  return (
    <ConfigProvider locale={zhCN}>
      <Suspense fallback={<div>Loading...</div>}>
        <RouterProvider router={router} />
      </Suspense>
    </ConfigProvider>
  )
}

export default App
```

### 2.4 更新路由配置

修改 `admin-frontend/src/router/index.tsx`，调整base path：

```typescript
import { createBrowserRouter, Navigate } from 'react-router-dom'
import { ROUTES } from '@/types/routes'
import { lazy } from 'react'

// ... 保持组件导入不变

// 获取base path
const getBasePath = () => {
  if (window.__POWERED_BY_WUJIE__) {
    // 在无界环境中，路由由主应用管理
    return ''
  }
  return ''
}

const router = createBrowserRouter([
  {
    path: '/',
    element: <Navigate to={ROUTES.ADMIN} replace />
  },
  {
    path: ROUTES.ADMIN,
    element: <Admin />,
    handle: {
      meta: {
        title: '首页',
      },
    },
    children: [
      // ... 保持原有子路由不变
    ],
  }
], {
  basename: getBasePath()
})

export default router
```

### 2.5 配置开发环境跨域

修改 `admin-frontend/vite.config.ts`：

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 5000,
    open: false, // 改为false，避免自动打开
    cors: true, // 启用CORS
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  },
  build: {
    outDir: 'dist',
    assetsDir: 'assets',
    sourcemap: false,
    minify: 'esbuild',
  },
})
```

## 第三阶段：应用间通信配置

### 3.1 用户状态同步

在主应用中创建 `src/composables/useAdminSync.js`：

```javascript
import { watch } from 'vue'
import { useUserStore } from '@/stores'
import { bus } from '@/plugins/wujie'

export function useAdminSync() {
  const userStore = useUserStore()

  // 监听用户状态变化，同步到子应用
  watch(
    () => userStore.userinfo,
    (newUserInfo) => {
      bus.$emit('user-info-updated', {
        userInfo: newUserInfo,
        token: userStore.token
      })
    },
    { deep: true }
  )

  watch(
    () => userStore.token,
    (newToken) => {
      bus.$emit('user-info-updated', {
        userInfo: userStore.userinfo,
        token: newToken
      })
    }
  )

  // 处理子应用发送的消息
  bus.$on('admin-user-updated', (userData) => {
    // 子应用更新了用户信息，同步到主应用
    userStore.updateUserInfo(userData)
  })

  return {
    syncUserToAdmin: () => {
      bus.$emit('user-info-updated', {
        userInfo: userStore.userinfo,
        token: userStore.token
      })
    }
  }
}
```

### 3.2 API请求统一配置

在子应用中创建 `admin-frontend/src/utils/request.ts`：

```typescript
import axios from 'axios'
import { message } from 'antd'

// 创建axios实例
const request = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || '/api',
  timeout: 10000,
})

// 请求拦截器
request.interceptors.request.use(
  (config) => {
    // 获取token - 优先从无界props获取，其次从localStorage
    let token = ''
    
    if (window.__WUJIE?.props?.token) {
      token = window.__WUJIE.props.token
    } else {
      token = localStorage.getItem('token') || ''
    }
    
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 响应拦截器
request.interceptors.response.use(
  (response) => {
    return response.data
  },
  (error) => {
    if (error.response?.status === 401) {
      // token过期，通知主应用退出登录
      if (window.__WUJIE?.bus) {
        window.__WUJIE.bus.$emit('admin-logout')
      } else {
        // 独立运行时的处理
        localStorage.removeItem('token')
        window.location.href = '/login'
      }
    } else {
      message.error(error.response?.data?.message || '请求失败')
    }
    
    return Promise.reject(error)
  }
)

export default request
```

## 第四阶段：构建与部署配置

### 4.1 开发环境配置

创建根目录的开发脚本 `dev-microfrontend.js`：

```javascript
const { spawn } = require('child_process')
const chalk = require('chalk')

console.log(chalk.blue('🚀 启动微前端开发环境'))

// 启动主应用 (C端)
const mainApp = spawn('pnpm', ['dev'], {
  stdio: 'inherit',
  shell: true,
  cwd: process.cwd()
})

// 启动子应用 (B端)
const subApp = spawn('pnpm', ['dev'], {
  stdio: 'inherit', 
  shell: true,
  cwd: './admin-frontend'
})

console.log(chalk.green('✅ 主应用启动中...'))
console.log(chalk.green('✅ 子应用启动中...'))
console.log(chalk.yellow('📝 主应用地址: http://localhost:5173'))
console.log(chalk.yellow('📝 子应用地址: http://localhost:5000'))

// 处理进程退出
process.on('SIGINT', () => {
  console.log(chalk.red('\n🛑 正在关闭微前端应用...'))
  mainApp.kill()
  subApp.kill()
  process.exit()
})
```

在根目录 `package.json` 添加脚本：

```json
{
  "scripts": {
    "dev:micro": "node dev-microfrontend.js",
    "build:micro": "pnpm build && cd admin-frontend && pnpm build"
  }
}
```

### 4.2 生产环境配置

#### Nginx配置示例

创建 `nginx.conf`：

```nginx
server {
    listen 80;
    server_name your-domain.com;
    
    # 主应用 (C端)
    location / {
        root /var/www/main-app;
        try_files $uri $uri/ /index.html;
        index index.html;
    }
    
    # 子应用静态资源 (B端)
    location /admin-static/ {
        alias /var/www/sub-app/;
        try_files $uri $uri/ /index.html;
        
        # 添加CORS头
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
        add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';
    }
    
    # API代理
    location /api/ {
        proxy_pass http://backend-server:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

#### Docker部署配置

创建 `Dockerfile.micro`：

```dockerfile
# 多阶段构建
FROM node:18-alpine as builder

# 构建主应用
WORKDIR /app/main
COPY package.json pnpm-lock.yaml ./
RUN npm install -g pnpm && pnpm install
COPY . .
RUN pnpm build

# 构建子应用
WORKDIR /app/sub
COPY admin-frontend/package.json admin-frontend/pnpm-lock.yaml ./
RUN pnpm install
COPY admin-frontend/ .
RUN pnpm build

# 生产镜像
FROM nginx:alpine
COPY --from=builder /app/main/dist /var/www/main-app
COPY --from=builder /app/sub/dist /var/www/sub-app
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

## 第五阶段：测试与验证

### 5.1 功能测试清单

- [ ] 主应用独立访问正常
- [ ] 子应用独立访问正常  
- [ ] 主应用中可以正常加载子应用
- [ ] 用户登录状态在两个应用间同步
- [ ] 路由跳转功能正常
- [ ] API请求携带正确的token
- [ ] 应用间通信功能正常
- [ ] 页面刷新后状态保持
- [ ] 浏览器前进后退功能正常
- [ ] 响应式布局适配

### 5.2 性能测试

- [ ] 首屏加载时间
- [ ] 子应用切换速度
- [ ] 内存使用情况
- [ ] 网络请求优化

## 总结

本方案实现了：

1. **零侵入集成**：现有代码改动最小化
2. **完全隔离**：样式和JS作用域完全隔离
3. **状态同步**：用户登录状态在应用间实时同步
4. **独立开发**：两个应用可以独立开发和部署
5. **统一体验**：用户感知是一个完整的应用

### 技术优势

- 🚀 **性能优秀**：预加载和保活机制确保快速切换
- 🔒 **安全隔离**：基于iframe的沙箱机制
- 🛠️ **开发友好**：支持热更新和独立调试
- 📱 **响应式**：完美支持移动端适配
- 🔄 **状态管理**：无缝的跨应用状态同步

这个方案可以让您快速实现微前端架构，同时保持优秀的开发体验和用户体验。
