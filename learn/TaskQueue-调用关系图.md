# TaskQueue 函数调用关系图

## 📋 系统概述

TaskQueue是一个高并发任务队列管理器，用于解决大量异步任务的调度和管理问题。本文档详细展示了系统的函数调用关系和执行流程。

## 🏗️ 系统架构图

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           TaskQueue 系统架构                                    │
└─────────────────────────────────────────────────────────────────────────────────┘
```

## 🔄 详细调用关系图

### 1. 初始化阶段

```
🏗️ 初始化阶段：
┌─────────────────┐
│  new TaskQueue  │
│   (constructor) │
└─────────┬───────┘
          │
          ▼
    ┌──────────────┐
    │ 初始化配置    │
    │ 初始化状态    │
    │ 初始化统计    │
    └──────────────┘
```

### 2. 任务添加阶段

```
📝 任务添加阶段：
┌─────────────┐      ┌──────────────┐      ┌─────────────────┐
│  addTask()  │─────▶│ 创建任务对象  │─────▶│ 优先级排序      │
└─────────────┘      └──────────────┘      └─────────┬───────┘
                                                     │
┌─────────────┐      ┌──────────────┐                │
│ addTasks()  │─────▶│ 循环调用     │◀───────────────┘
└─────────────┘      │ addTask()    │
                     └──────────────┘
                            │
                            ▼
                   ┌─────────────────┐
                   │ updateProgress() │
                   └─────────────────┘
```

### 3. 队列执行阶段

```
🚀 队列执行阶段：
┌─────────────┐      ┌──────────────┐      ┌─────────────────┐
│   start()   │─────▶│ 状态检查     │─────▶│ processQueue()  │
└─────────────┘      │ 初始化时间    │      └─────────┬───────┘
                     └──────────────┘                │
                                                     │
                     ┌──────────────┐                │
                     │ Promise轮询   │◀───────────────┘
                     │ checkComplete │
                     └──────┬───────┘
                            │
                            ▼
                   ┌─────────────────┐
                   │  isComplete()   │
                   └─────────────────┘
```

### 4. 核心调度循环

```
🔄 核心调度循环：
                   ┌─────────────────┐
           ┌──────▶│ processQueue()  │◀──────┐
           │       └─────────┬───────┘       │
           │                 │               │
           │                 ▼               │
           │       ┌─────────────────┐       │
           │       │ 并发控制检查     │       │
           │       │ while循环       │       │
           │       └─────────┬───────┘       │
           │                 │               │
           │                 ▼               │
           │       ┌─────────────────┐       │
           │       │ tasks.shift()   │       │
           │       │ 取出任务        │       │
           │       └─────────┬───────┘       │
           │                 │               │
           │                 ▼               │
           │       ┌─────────────────┐       │
           │       │ executeTask()   │       │
           │       │ (异步执行)      │       │
           │       └─────────┬───────┘       │
           │                 │               │
           │                 ▼               │
           │       ┌─────────────────┐       │
           │       │ setTimeout()    │───────┘
           │       │ 定时器调度      │
           │       └─────────────────┘
           │
           │ 🔧 控制操作：
           │ ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
           └─│   pause()   │    │  resume()   │    │   stop()    │
             └─────────────┘    └─────────┬───┘    └─────────────┘
                                          │
                                          ▼
                                ┌─────────────────┐
                                │ processQueue()  │
                                └─────────────────┘
```

### 5. 任务执行流程

```
⚡ 任务执行流程：
┌─────────────────┐      ┌──────────────────┐      ┌─────────────────┐
│ executeTask()   │─────▶│ 状态设置         │─────▶│ AbortController │
└─────────────────┘      │ executing        │      │ 创建取消控制     │
                         └──────────────────┘      └─────────┬───────┘
                                                             │
                         ┌──────────────────┐                │
                         │ Promise.race()   │◀───────────────┘
                         │ 超时控制         │
                         └─────────┬────────┘
                                   │
                    ┌──────────────┼──────────────┐
                    │              │              │
                    ▼              ▼              ▼
          ┌─────────────────┐ ┌─────────────┐ ┌─────────────────┐
          │ task.fn()       │ │ 超时Promise │ │ 取消信号        │
          │ 业务逻辑执行     │ │ timeout     │ │ AbortSignal     │
          └─────────┬───────┘ └─────────────┘ └─────────────────┘
                    │
          ┌─────────┼─────────┐
          │                  │
          ▼                  ▼
┌─────────────────┐  ┌─────────────────┐
│ 成功处理        │  │ handleTaskError() │
│ - 更新状态      │  │ 错误处理         │
│ - 记录结果      │  └─────────┬───────┘
│ - 触发回调      │            │
└─────────┬───────┘            │
          │                    ▼
          │          ┌─────────────────┐
          │          │ 重试判断        │
          │          │ retries < max   │
          │          └─────────┬───────┘
          │                    │
          │          ┌─────────┼─────────┐
          │          │                  │
          │          ▼                  ▼
          │ ┌─────────────────┐  ┌─────────────────┐
          │ │ 重试处理        │  │ 最终失败        │
          │ │ - 延迟等待      │  │ - 标记失败      │
          │ │ - 重新入队      │  │ - 触发错误回调   │
          │ └─────────────────┘  └─────────────────┘
          │
          ▼
┌─────────────────┐
│ finally块       │
│ - 清理执行状态   │
│ - updateProgress │
│ - 请求间隔      │
└─────────────────┘
```

### 6. 状态监控系统

```
📊 状态监控系统：
┌─────────────────┐      ┌──────────────────┐
│ updateProgress()│─────▶│ 计算进度信息     │
└─────────────────┘      │ - 百分比         │
          ▲               │ - 各状态数量     │
          │               │ - 执行时间       │
          │               └──────────┬───────┘
          │                          │
          │               ┌──────────▼───────┐
          └───────────────│ onProgress()     │
                          │ 触发进度回调     │
                          └──────────────────┘

┌─────────────────┐      ┌──────────────────┐
│ getResults()    │─────▶│ 返回执行结果     │
└─────────────────┘      │ - 统计信息       │
                         │ - 成功任务列表   │
┌─────────────────┐      │ - 失败任务列表   │
│ getStatus()     │─────▶│ - 成功率计算     │
└─────────────────┘      └──────────────────┘
```

### 7. 失败恢复系统

```
🔄 失败恢复系统：
┌─────────────────┐      ┌──────────────────┐      ┌─────────────────┐
│retryFailedTasks()│─────▶│ 复制失败任务     │─────▶│ 重置任务状态    │
└─────────────────┘      │ 清空失败记录     │      │ 重新入队        │
                         └──────────────────┘      └─────────┬───────┘
                                                             │
                                                             ▼
                                                   ┌─────────────────┐
                                                   │ updateProgress() │
                                                   └─────────────────┘
```

### 8. 资源清理系统

```
🧹 资源清理系统：
┌─────────────────┐      ┌──────────────────┐
│   destroy()     │─────▶│ stop()           │
└─────────────────┘      └─────────┬────────┘
                                   │
┌─────────────────┐                │
│   clear()       │◀───────────────┘
└─────────┬───────┘
          │
          ▼
┌─────────────────┐      ┌──────────────────┐
│ resetStats()    │─────▶│ 清理定时器       │
└─────────────────┘      │ clearTimeout()   │
                         └──────────────────┘
```

### 9. 工厂函数系统

```
🏭 工厂函数系统：
┌─────────────────────────────┐      ┌──────────────────┐
│createSpecificationTaskQueue()│─────▶│ 预设配置合并     │
└─────────────────────────────┘      └─────────┬────────┘
                                               │
┌─────────────────────────────┐                │
│     createTaskQueue()       │────────────────┘
└─────────────────────────────┘                │
                                               ▼
                                     ┌──────────────────┐
                                     │ new TaskQueue()  │
                                     └──────────────────┘
```

## 🎯 关键调用链路

### 主要执行路径

1. **初始化**: `constructor` → 配置设置 → 状态初始化
2. **添加任务**: `addTask` → 任务创建 → 排序 → `updateProgress`
3. **开始执行**: `start` → `processQueue` → `executeTask` → `handleTaskError`
4. **调度循环**: `processQueue` → `setTimeout` → `processQueue` (递归)
5. **状态监控**: `updateProgress` → `onProgress` → UI更新

### 关键决策点

| 函数                  | 决策点           | 影响               |
| --------------------- | ---------------- | ------------------ |
| `processQueue()`    | 并发控制检查     | 是否启动新任务     |
| `executeTask()`     | Promise.race结果 | 成功/超时/失败路径 |
| `handleTaskError()` | 重试次数判断     | 重试/最终失败      |
| `isComplete()`      | 队列状态检查     | 是否结束执行       |

### 异步调用链

```javascript
// 主要的异步调用模式
start() → Promise(checkComplete) → isComplete()
executeTask() → Promise.race([task.fn(), timeout]) → success/error
handleTaskError() → sleep() → retry/fail
processQueue() → setTimeout → processQueue (递归)
```

### 控制流

```javascript
// 控制操作的调用流程
pause() → 设置暂停标志
resume() → 清除标志 → processQueue()
stop() → 设置标志 → 取消所有任务
destroy() → stop() → clear() → 清理资源
```

## 📊 函数调用频率分析

### 高频调用函数

- `processQueue()` - 核心调度循环，持续调用
- `updateProgress()` - 每次状态变化都会调用
- `executeTask()` - 每个任务执行时调用

### 中频调用函数

- `handleTaskError()` - 任务失败时调用
- `addTask()` - 添加任务时调用
- `isComplete()` - 检查完成状态时调用

### 低频调用函数

- `start()` - 队列启动时调用一次
- `pause()/resume()/stop()` - 用户控制操作
- `destroy()` - 队列销毁时调用一次

## 🔍 调用关系特点

### 1. 递归调用

- `processQueue()` 通过 `setTimeout` 实现自递归调用
- `checkComplete()` 在 `start()` 中实现轮询递归

### 2. 异步调用

- 大部分核心函数都是异步的
- 使用 Promise 和 async/await 处理异步流程

### 3. 事件驱动

- 通过回调函数实现事件通知
- 状态变化触发相应的回调函数

### 4. 状态机模式

- 任务状态: pending → executing → completed/failed
- 队列状态: 初始化 → 运行 → 暂停/停止 → 完成

## 💡 优化建议

### 性能优化

1. 减少 `updateProgress()` 的调用频率
2. 优化任务排序算法
3. 使用对象池减少内存分配

### 可维护性优化

1. 分离关注点，将监控逻辑独立
2. 增加更多的钩子函数
3. 提供更细粒度的配置选项

### 扩展性优化

1. 支持插件机制
2. 提供更多的预设配置
3. 支持任务依赖关系

---

*本文档详细描述了TaskQueue系统的函数调用关系，有助于理解系统架构和优化系统性能。*
